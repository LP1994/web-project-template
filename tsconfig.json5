{
  /*
  1、指定要包含在程序中的文件允许列表，如果找不到任何文件，则会发生错误，也不要设置成空数组。
  2、当您只有少量文件并且不需要使用全局来引用许多文件时，这很有用，如果您需要，请使用“include”。
  3、如果tsconfig.json中不存在“files”或“include”属性，编译器默认包括包含目录和子目录中的所有文件，但“exclude”指定的文件除外，指定“files”属性时，仅包括那些文件和“include”指定的文件。
  4、必须是文件，包括通过通配符匹配到的文件，但是不能是文件夹。
  */
  // 通过通配符匹配到的文件："**/*.spec.ts"。
  // "files": [
  // "./xxx/core.ts",
  // "**/*.spec.ts",
  // "./src/**/*.ts"
  // ],

  /*
  1、extends的值是一个字符串，其中包含要继承的另一个配置文件的路径，该路径可能使用Node.js样式解析。
  2、首先加载基本文件中的配置，然后被继承配置文件中的配置覆盖，在配置文件中找到的所有相对路径都将相对于它们所在的配置文件进行解析。
  3、值得注意的是，继承配置文件中的包含和排除文件会覆盖基本配置文件中的文件，并且不允许配置文件之间的循环。
  4、目前，唯一从继承中排除的顶级属性是“references”。
  5、在配置文件中找到的具有相对路径的属性（未从继承中排除）将相对于它们起源的配置文件进行解析。
  6、也可以引用npm上的配置包，如："extends": "@tsconfig/node18/tsconfig.json"。
  */
  // "extends": "./xxx/base.json",

  /*
  1、指定与要包含在编译中的文件匹配的全局模式列表，如果tsconfig.json中不存在“files”或“include”属性，编译器默认包括包含目录和子目录中的所有文件，但“exclude”指定的文件除外，需要TypeScript 2.0或更高版本。
  2、指定要包含在程序中的文件名或模式数组，这些文件名相对于包含tsconfig.json文件的目录进行解析。
  3、“include”和"exclude"支持通配符以生成全局模式：
  *：匹配零个或多个字符（不包括目录分隔符）。
  ?：匹配任何一个字符（不包括目录分隔符）。
  4、如果全局模式不包含文件扩展名，则仅包含具有受支持扩展名的文件（例如，默认情况下为.ts、.tsx和.d.ts，如果allowJs设置为true，则为.js和.jsx）。
  */
  // **/：匹配任何嵌套到任何级别的目录。
  // 读取所有可识别的src目录下的文件："./src/**/*"。
  "include": [
    "./tsconfig.json5",
    "./src/**/*.ts",
    "./src/**/*.cts",
    "./src/**/*.mts",
    "./src/**/*.tsx",
    "./src/**/*.d.ts",
    "./src/**/*.d.cts",
    "./src/**/*.d.mts",
    "./src/**/*.ts.vue",
    "./src/**/*.cts.vue",
    "./src/**/*.mts.vue",
    "./src/**/*.tsx.vue"
  ],
  /*
  1、指定解析包含时应跳过的文件名或模式数组。
  2、指定要从编译中排除的文件列表。“exclude”属性仅影响通过“include”属性包含的文件，而不影响“files”属性，全局模式需要TypeScript 2.0或更高版本。
  3、重要的：exclude仅更改由于include设置而包含的文件，由于代码中的导入语句、类型包含、/// <reference 指令或在“files”中指定，由exclude指定的文件仍然可以成为代码库的一部分。
  4、它不是一种阻止文件被包含在代码库中的机制——它只是改变了“include”设置找到的内容。
  5、匹配模式的用法可以参见“include”选项的说明。
  */
  "exclude": [
    "./dist",
    "./node_modules",
    "./bower_components",
    "./jspm_packages"
  ],
  // 确保你在运行程序前自动编译已保存变更后的代码。
  "compileOnSave": true,
  "compilerOptions": {
    /*
    允许无法访问的代码。
    1、有三个值：
    undefined：默认，向编辑提供建议作为警告。
    true：无法访问的代码被忽略。
    false：引发有关无法访问代码的编译器错误。
    2、这些警告仅与可证明由于使用JavaScript语法而无法访问的代码有关。
    3、这不会影响基于由于类型分析而似乎无法访问的代码的错误。
    */
    "allowUnreachableCode": false,
    /*
    允许执行不到的标签。
    1、有三个值：
    undefined：默认，向编辑提供建议作为警告。
    true：未使用的标签被忽略。
    false：引发关于未使用标签的编译器错误。
    */
    "allowUnusedLabels": false,
    /*
    确保您的文件在ECMAScript严格模式下解析，并为每个源文件发出"use strict"。
    1、ECMAScript严格模式是在ES5中引入的，它为JavaScript引擎的运行时提供行为调整以提高性能，并抛出一组错误而不是默默地忽略它们。
    */
    "alwaysStrict": true,
    /*
    类型检查时区分未定义和不存在。
    1、启用exactOptionalPropertyTypes后，TypeScript应用更严格的规则来处理它如何处理“type”或带“?”的属性的“interfaces”，如：
    此接口声明有一个属性可以是两个字符串之一：“dark”或“light”，或者它不应该在对象中。
    interface UserDefaults {
      colorThemeOverride?: "dark" | "light";
    }
    2、exactOptionalPropertyTypes使TypeScript真正强制执行作为可选属性提供的定义。
    */
    "exactOptionalPropertyTypes": true,
    /*
    在switch语句中报告失败案例的错误，确保switch语句中的任何非空大小写都包括break或return，这意味着您不会意外地发送一个案例失败的错误。
    */
    "noFallthroughCasesInSwitch": true,
    /*
    为隐含“any”类型的表达式和声明启用错误报告。
    */
    "noImplicitAny": true,
    /*
    确保使用重写修饰符标记派生类中的重写成员。
    1、当处理使用继承的类时，子类可能与在基类中重命名时重载的函数“不同步”。
    2、使用noImplicitOverride您可以确保子类永远不会不同步，方法是确保覆盖的函数包含关键字“override”。
    3、为true时的作用：当子类中的某个方法没有显示的使用关键字“override”来修饰该方法会覆盖父类的同名方法时，就发出错误提示。
    */
    "noImplicitOverride": true,
    /*
    为未在函数中显式返回的代码路径启用错误报告。
    1、启用后，TypeScript将检查函数中的所有代码路径以确保它们返回值。
    */
    "noImplicitReturns": true,
    /*
    当“this”被指定为“any”类型时，启用错误报告。
    1、使用隐含的“any”类型在“this”表达式上引发错误。
    */
    "noImplicitThis": true,
    /*
    强制对使用索引类型声明的键使用索引访问器。
    1、此设置确保通过“.”（obj.key）语法访问字段和“索引”（obj[“key”]）以及在类型中声明属性的方式之间的一致性。
    2、如果没有这个标志，TypeScript将允许您使用点语法来访问未定义的字段。
    3、此标志的目标是在您的调用语法中表明您对该属性存在的确定程度。
    4、打开标志会引发错误，因为未知字段使用点语法而不是索引语法。
    5、设置成true时，只能使用“索引”（obj[“key”]）的语法进行调用，如果用“.”（obj.key）语法就会报错，这么做的目标是在您的调用语法中表明您对该属性存在的确定程度。
    */
    "noPropertyAccessFromIndexSignature": false,
    /*
    使用索引访问时，向类型添加“undefined”。
    1、TypeScript有一种方法可以通过索引签名来描述对象上具有未知键但已知值的对象。
    2、开启noUncheckedIndexedAccess会将undefined添加到类型中任何未声明的字段。
    */
    "noUncheckedIndexedAccess": false,
    /*
    报告未使用的局部变量的错误。
    */
    "noUnusedLocals": true,
    /*
    报告函数中未使用参数的错误。
    */
    "noUnusedParameters": true,
    /*
    启用所有严格类型检查选项。
    1、strict标志支持范围广泛的类型检查行为，从而更有力地保证程序的正确性，启用此选项相当于启用所有严格模式族选项，如下所述，然后，可以根据需要关闭各个严格模式族检查。
    2、TypeScript的未来版本可能会在此标志下引入更多更严格的检查，因此TypeScript的升级可能会导致程序中出现新的类型错误，在适当且可能的情况下，将添加相应的标志以禁用该行为。
    3、目前将默认启用如下选项的严格检查：alwaysStrict、strictNullChecks、strictBindCallApply、strictFunctionTypes、strictPropertyInitializatio、noImplicitAny、noImplicitThis、useUnknownInCatchVariables。
    */
    "strict": true,
    /*
    检查“bind”、“call”和“apply”方法的参数是否与原始函数匹配。
    */
    "strictBindCallApply": true,
    /*
    分配函数时，请检查以确保参数和返回值与子类型兼容。
    1、启用后，此标志会导致更正确地检查函数参数。
    2、在开发此功能的过程中，我们发现了大量固有的不安全类层次结构，包括DOM中的一些。因此，该设置仅适用于以“函数语法”编写的函数，不适用于以“方法语法”编写的函数。
    */
    "strictFunctionTypes": true,
    /*
    在进行类型检查时，请考虑“null”和“undefined”。
    1、当strictNullChecks为false时，语言会有效地忽略null和undefined，这可能会导致运行时出现意外错误。
    2、当strictNullChecks为true时，null和undefined有它们自己不同的类型，如果你试图在需要具体值的地方使用它们，你会得到一个类型错误。
    */
    "strictNullChecks": true,
    /*
    检查构造函数中声明但未设置的类属性。
    1、当设置为true时，TypeScript将在声明了类属性但未在构造函数中设置时引发错误。
    */
    "strictPropertyInitialization": true,
    /*
    默认catch子句变量为“unknown”，而不是“any”。
    1、在TypeScript 4.0中，添加了支持以允许将catch子句中的变量类型从any更改为unknown。
    2、此模式确保错误处理代码变得更加全面，因为您无法保证提前抛出的对象是错误子类。启用标志useUnknownInCatchVariables后，您就不需要额外的语法（：unknown）或linter规则来尝试强制执行此行为。
    */
    "useUnknownInCatchVariables": true,
    /*
    允许从模块访问UMD全局。
    1、当设置为true时，allowUmdGlobalAccess允许您从模块文件内部访问作为全局变量的UMD导出。模块文件是具有导入和/或导出的文件。如果没有此标志，则使用UMD模块的导出需要导入声明。
    2、此标志的一个示例用例是一个Web项目，您知道特定库（如jQuery或Lodash）在运行时始终可用，但您无法通过导入访问它。
    */
    "allowUmdGlobalAccess": true,
    /*
    指定用于解析非相对模块名称的基目录。
    1、允许您设置基本目录以解析非绝对模块名称。
    2、在此项目中使用"baseUrl": "./"，TypeScript将查找从与tsconfig.json相同的文件夹开始的文件。
    3、如果您厌倦了总是看起来像“../”或“./”的导入，或者需要在移动文件时更改它们，这是解决这个问题的好方法。
    */
    "baseUrl": "./",
    /*
    设置程序的模块系统。
    1、对于“node”项目，您很可能需要设置成“commonjs”。
    2、更改“module”选项会影响“moduleResolution”选项。
    3、该选项默认情况下受“target”选项影响，如果“target”选项值是ES3或ES5，则该选项默认为“commonjs”，否则该选项默认为：es6（别名：es2015）。
    4、允许的值有：none（等同于commonjs）、commonjs、amd、umd、system、es6（别名：es2015）、es2020、es2022、esnext、node12、node16、nodenext。
    5、如果“target”选项值为ES3或ES5，强烈建议将该选项值设置为commonjs。
    6、如果你想知道es6（别名：es2015）和es2020之间的区别，es2020增加了对“动态导入”和“import.meta”的支持。
    7、在夜间构建中可用，实验性的node12、node16和nodenext模式与Node的原生ECMAScript模块支持集成。
    8、发出的JavaScript使用commonjs或es2020输出，具体取决于“文件扩展名”和最近的package.json中“type”设置的值，“Module resolution”的工作方式也不同，您可以在手册中了解更多信息。
    */
    "module": "es2015",
    /*
    指定TypeScript如何从给定“模块说明符（也就是导入文件时写的字符串形式的文件路径）”中查找文件。
    1、如果“module”选项值是amd、umd、system或es6（别名：es2015），该选项默认值为classic，如果“module”选项值是node12、node16、nodenext，该选项默认值为node。
    2、允许的值有：classic、node、node12、node16、nodenext。
    3、选项值node用于Node.js的CommonJS实现。
    4、选项值node12、node16、nodenext从TypeScript 4.5开始，用于Node.js的ECMAScript模块支持。
    5、选项值classic用于TypeScript 1.6之前的版本。您可能不需要在现代代码中使用经典
    */
    "moduleResolution": "classic",
    /*
    默认情况下（noResolve的默认值是false），TypeScript将检查“import”和“<reference”指令的初始文件集，并将这些已解析的文件添加到您的程序中。
    1、如果设置了noResolve，则不会发生此过程。但是，仍会检查import语句以查看它们是否解析为有效的模块，因此您需要确保通过其他方式满足此要求。
    */
    "noResolve": false,
    /*
    指定将导入重新映射到其他查找位置的一组条目。
    1、允许你声明TypeScript应该如何解析你的require/imports中的导入。
    2、您也可以告诉TypeScript文件解析器支持许多自定义前缀来查找代码。此模式可用于避免代码库中较长的相对路径，如："config/*": [ "app/_config/*" ]。
    3、该项的功用可以理解为跟webpack中的路径别名一样的用途。
    */
    "paths": {
      "axios": [
        "node_modules/axios/dist/axios.min.js"
      ],
      "echarts": [
        "node_modules/echarts/dist/echarts.min.js"
      ],
      "ElementUI_V2_CSS": [
        "node_modules/element-ui/lib/theme-chalk/index.css"
      ],
      "ElementUI_V2": [
        "node_modules/element-ui/lib/index.js"
      ],
      "ElementUI_CSS": [
        "node_modules/element-plus/dist/index.css"
      ],
      "ElementUI": [
        "node_modules/element-plus/dist/index.full.min.js"
      ],
      "jQuery": [
        "node_modules/jquery/dist/jquery.min.js"
      ],
      "$": [
        "node_modules/jquery/dist/jquery.min.js"
      ],
      "SwiperCSS": [
        "node_modules/swiper/swiper-bundle.min.css"
      ],
      "Swiper": [
        "node_modules/swiper/swiper-bundle.min.js"
      ],
      "Vue": [
        "node_modules/vue/dist/vue.global.prod.js"
      ],
      "VueRouter": [
        "node_modules/vue-router/dist/vue-router.global.prod.js"
      ],
      "Vuex": [
        "node_modules/vuex/dist/vuex.global.prod.js"
      ],
      "tslib": [
        "node_modules/tslib/tslib.es6.js"
      ]
    },
    /*
    启用.json文件的导入。
    1、允许导入带有“.json”扩展名的模块，这是“node”项目中的常见做法。这包括根据静态JSON形状为导入生成类型。
    2、启用该选项允许导入JSON，并验证该JSON文件中的类型。
    */
    "resolveJsonModule": true,
    /*
    指定源文件中的根文件夹。
    1、所有非声明输入文件的最长公共路径。如果设置了复合，则默认为包含tsconfig.json文件的目录。
    2、当TypeScript编译文件时，它在输出目录中保持与输入目录中相同的目录结构。
    */
    "rootDir": "./",
    /*
    默认情况下，所有可见的“@types”包都包含在您的编译中。
    1、任何封闭文件夹的node_modules/@types中的包都被认为是可见的。
    */
    "typeRoots": [
      "./node_modules/@types"
    ],
    /*
    指定要包含的类型包名称，而不在源文件中引用。
    1、此功能与typeRoots的不同之处在于它只指定您想要包含的确切类型，而typeRoots支持说您想要特定的文件夹。
    2、空数组将禁用自动引入@types包。
    */
    // "types": [],
    /*
    在项目中为TypeScript或JavaScript生成对应的.d.ts文件。
    1、这些.d.ts文件是描述模块外部API的类型定义文件。
    2、使用.d.ts文件，TypeScript等工具可以为无类型代码提供智能感知和准确类型。
    */
    "declaration": true,
    /*
    提供一种方法来配置发出声明文件的根目录。
    */
    "declarationDir": "./test/",
    /*
    为d.ts文件创建源映射。
    1、如果您使用“project references”，您应该强烈考虑将其打开。
    */
    "declarationMap": true,
    /*
    为迭代发出更兼容但冗长且性能更低的JavaScript。
    1、降级是TypeScript的术语，用于转换为旧版本的JavaScript。这个标志是为了支持更准确地实现现代JavaScript如何迭代旧JavaScript运行时中的新概念。
    2、如果“target”选项值为es3、es5，则强烈建议启用该选项，因为会使用最严格合规（符合ECMAScript的标准）的转换代码来模拟ES6的迭代器。
    */
    "downlevelIteration": true,
    /*
    在输出文件的开头发出UTF-8字节顺序标记（BOM）。
    1、一些运行时环境需要BOM才能正确解释JavaScript文件；其他人要求它不存在。默认值false通常是最好的，除非您有理由更改它。
    */
    "emitBOM": false,
    /*
    仅输出d.ts文件，不输出JavaScript文件。
    */
    "emitDeclarationOnly": false,
    /*
    允许在每个项目中从tslib导入一次助手函数，而不是在每个文件中包含它们。
    1、对于某些降级操作，TypeScript使用一些帮助代码进行扩展类、扩展数组或对象以及异步操作等操作。
    2、默认情况下，这些助手被插入到使用它们的文件中。如果在许多不同的模块中使用相同的帮助程序，这可能会导致代码重复。
    */
    "importHelpers": true,
    /*
    为仅用于类型的导入指定发射/检查行为。
    1、允许的值：
    remove：删除仅引用类型的导入语句的默认行为。
    preserve：保留其值或类型从未使用过的所有导入语句。这可能会导致保留导入/副作用。
    error：这会保留所有导入（与 preserve 选项相同），但当值导入仅用作类型时会出错。如果您想确保没有意外导入任何值，但仍使副作用导入显式，这可能很有用。
    2、此标志有效，因为您可以使用导入类型显式创建一个永远不应发送到 JavaScript 中的导入语句。
    3、优先设置成“remove”，但是fork-ts-checker-webpack-plugin插件建议设置成“preserve”，如果TypeScript >= 3.8.0的话。
    */
    "importsNotUsedAsValues": "preserve",
    /*
    在发出的JavaScript中包含sourceMap文件。
    1、与sourceMap互斥。
    2、设置后，TypeScript不会写出.js.map文件来提供源映射，而是将源映射内容嵌入到.js文件中。
    3、虽然这会导致JS文件变大，但在某些场景下会很方便。例如，您可能希望在不允许提供.map文件的网络服务器上调试JS文件。
    4、
    */
    "inlineSourceMap": false,
    /*
    在发出的JavaScript中的sourcemaps中包含源代码。
    1、设置后，TypeScript会将.ts文件的原始内容作为嵌入字符串包含在源映射中（使用源映射的sourcesContent属性）。这在与inlineSourceMap相同的情况下通常很有用。
    2、需要设置sourceMap或inlineSourceMap。
    */
    "inlineSources": false,
    /*
    指定调试器应在其中定位映射文件的位置，而不是生成的位置。
    1、指定调试器应该定位映射文件而不是生成的位置的位置。此字符串在源映射中逐字处理。
    */
    // "mapRoot": "https://my-website.com/debug/sourcemaps/",
    /*
    设置用于发射文件的换行符。
    1、指定发出文件时要使用的行尾序列：“CRLF”（dos）或“LF”（unix）。
    2、允许的值：crlf、lf。
    */
    "newLine": "crlf",
    /*
    禁用从编译发出文件。
    1、不要发出编译器输出文件，如JavaScript源代码、源映射或声明。
    2、这为Babel或swc等其他工具腾出空间来处理将TypeScript文件转换为可以在JavaScript环境中运行的文件。
    3、然后，您可以将TypeScript用作提供编辑器集成的工具，并用作源代码类型检查器。
    */
    "noEmit": false,
    /*
    禁用在编译输出中生成自定义帮助程序函数，如“__extends”。
    1、您可以在全局范围内为您使用的助手提供实现，并完全关闭助手函数的发射，而不是使用importHelpers导入助手。
    */
    "noEmitHelpers": false,
    /*
    如果报告了任何类型检查错误，则禁用发送文件。
    1、如果报告了任何错误，请不要发出编译器输出文件，如JavaScript源代码、源映射或声明。
    2、这默认为false，这使得在“watch-like”的环境中使用TypeScript变得更容易，在这种环境中，您可能希望在确保解决所有错误之前在另一个环境中查看代码更改的结果。
    */
    "noEmitOnError": true,
    /*
    为所有发出的文件指定输出文件夹。
    1、如果指定，.js（以及 .d.ts、.js.map 等）文件将被发送到此目录。保留原始源文件的目录结构。
    2、如果未指定，.js文件将在与生成它们的.ts文件相同的目录中发出。
    */
    "outDir": "./test/",
    /*
    如果指定，所有全局（非模块）文件将连接到指定的单个输出文件中。
    1、注意：除非“module”选项值是none、system或amd，否则不能使用outFile。此选项不能用于捆绑commonjs或es6模块。
    2、如果“module”选项值是system或amd，所有的模块文件也将在所有全局内容之后连接到这个文件中。
    */
    // "outFile": "./test/outFile.js",
    /*
    禁用擦除生成代码中的“const enum”声明。
    1、不要删除生成代码中的const枚举声明。const枚举提供了一种通过发出枚举值而不是引用来减少应用程序在运行时的整体内存占用的方法。
    2、这实质上使此类const枚举仅成为源代码功能，没有运行时跟踪。
    */
    "preserveConstEnums": true,
    /*
    在JavaScript输出中保留未使用的导入值，否则将被删除。
    1、在某些情况下，TypeScript无法检测到您正在使用导入，或使用Svelte或Vue等“编译为 HTML”语言的代码，如：
    import { Animal } from "./animal.js";
    eval("console.log(new Animal().isDangerous())");
    2、
    */
    "preserveValueImports": true,
    
    
    
    
    "target": "es2015",
    "sourceMap": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "lib": [
      "es5",
      "es2015",
      "dom"
    ]
  }
}
