mongoose官方文档：
https://mongoosejs.com/
https://mongoosejs.com/docs/index.html



1、关于“mongoose”的介绍
mongoose，为node.js建立优雅的mongodb对象模型。
让我们面对现实吧，编写MongoDB验证、铸造和业务逻辑的模板是一种拖累。这就是为什么我们写了Mongoose。
Mongoose提供了一个直接的、基于“Schema，即：模式”的解决方案来为你的应用程序数据建模。它包括内置的类型转换、验证、查询构建、业务逻辑挂钩等，开箱即用。
在Mongoose中，所有的东西都来自于一个“Schema，即：模式”。
Mongoose中的一切都以“Schema，即：模式”开始。每个“Schema，即：模式”都映射到MongoDB的“Collection”，并定义了该“Collection”中的“Document”的形状。



2、Types.ObjectId、Schema.Types.ObjectId
在TypeScript中创建一个interface接口时，如果需要在其中定义一个ObjectId类型的属性时，应该使用“Types.ObjectId”。
例如：
interface IUser {
  name: string;
  email: string;
  organization: Types.ObjectId;
}
但是如果是在Schema中定义一个ObjectId类型的属性时，应该使用“Schema.Types.ObjectId”。
例如：
const userSchema = new Schema<IUser>({
  name: { type: String, required: true },
  email: { type: String, required: true },
  organization: { type: Schema.Types.ObjectId, ref: 'Organization' }
});
这是因为Schema.Types.ObjectId是一个继承自SchemaType的类，而不是你用来创建一个新的MongoDB ObjectId的类。



3、自动类型推理
Mongoose的Schema是你如何告诉Mongoose你的Document是什么样子的。
Mongoose的Schema与TypeScript的interfaces是分开的，所以你需要同时定义一个TypeScript的interfaces和一个Mongoose的Schema；或者依靠Mongoose从Schema定义中自动推断类型。
Mongoose还可以从你的Schema定义中自动推断出文档类型（相当于TypeScript的interfaces、type），如下所示。
import { Schema, InferSchemaType } from 'mongoose';

// Document interface
// No need to define TS interface any more.
// interface User {
//   name: string;
//   email: string;
//   avatar?: string;
// }

// Schema
const schema = new Schema({
  name: { type: String, required: true },
  email: { type: String, required: true },
  avatar: String
});

type User = InferSchemaType<typeof schema>;
// InferSchemaType will determine the type as follows:
// type User = {
//   name: string;
//   email: string;
//   avatar?: string;
// }

// `UserModel` will have `name: string`, etc.
const UserModel = mongoose.model('User', schema);

使用自动类型推理有一些注意事项：
1、你需要在你的tsconfig.json中设置 strictNullChecks: true 或 strict: true。或者，如果你在命令行中设置标志，则为--strictNullChecks或--strict。在禁用严格模式的情况下，自动类型推理存在已知的问题。
2、你需要在new Schema()调用中定义你的模式。不要把你的模式定义分配给一个临时变量。像 const schemaDefinition = { name: String }; const schema = new Schema(schemaDefinition); 这样做是行不通的。
3、如果你在模式中指定了timestamps选项，Mongoose会将createdAt和updateAt添加到你的模式中，除非你还指定了方法、虚拟或静态。在使用时间戳和方法/虚拟/静态选项的类型推理中存在一个已知的问题。如果你使用方法、虚拟和静态，你要负责在你的模式定义中添加createdAt和updateAt。

如果自动类型推理对你不起作用，你总是可以退回到文档接口定义。



4、通用参数，Schema类的泛型参数
TypeScript中的Mongoose Schema类有4个通用参数：
DocType：一个描述数据如何保存在MongoDB中的接口，相当于TypeScript的interfaces、type。
M：Mongoose的Model类型。如果没有要定义的“查询助手”或“实例方法”，可以省略。默认值：Model<DocType, any, any>
TInstanceMethods：一个包含Schema的“实例方法”的接口。默认值：{}
TQueryHelpers：一个包含在Schema上定义的“查询助手”的接口。默认值：{}
例如：
Schema<
// 通常指“文档接口”类型
IKitty,
// Model类型
IKittyModel,
// 通常指定义“实例方法”的接口类型
IKittyMethods,
// 通常指定义“查询助手”的接口类型
IKittyQueryHelpers
>



5、Schema vs Interface fields
会报错！因为Schema类中定义的属性都必须在interface中列出！
import { Schema, Model } from 'mongoose';

interface User {
  name: string;
  email: string;
  avatar?: string;
}

// Object literal may only specify known properties, but 'emaill' does not exist in type ...
// Did you mean to write 'email'?
const schema = new Schema<User>({
  name: { type: String, required: true },
  emaill: { type: String, required: true },
  avatar: String
});

不会报错！在interface中定义的属性不一定全要在Schema类中定义，但是Schema类中定义的属性都必须在interface中列出！
import { Schema, Model } from 'mongoose';

interface User {
  name: string;
  email: string;
  avatar?: string;
  createdAt: number;
}

const schema = new Schema<User, Model<User>>({
  name: { type: String, required: true },
  email: { type: String, required: true },
  avatar: String
});



6、关于定义“文档接口（即interface）”中的数组
当你在“文档接口（即interface）”中定义一个数组时，我们建议对“原始数组”使用Mongoose的Types.Array类型，或对“文档数组”使用Types.DocumentArray。
例如：
import { Schema, Model, Types } from 'mongoose';

interface BlogPost {
  _id: Types.ObjectId;
  title: string;
}

interface User {
  tags: Types.Array<string>;
  blogPosts: Types.DocumentArray<BlogPost>;
}

const schema = new Schema<User, Model<User>>({
  tags: [String],
  blogPosts: [{ title: String }]
});

也就是说，原本是这么定义的：
interface User {
  tags: Array<string>;
  blogPosts: Array< { title: string; } >;
}
现在是这么定义的：
interface User {
  tags: Types.Array<string>;
  blogPosts: Types.DocumentArray<{ title: string; }>;
}

在处理默认值时，使用Types.DocumentArray很有帮助。
例如，BlogPost有一个_id属性，Mongoose会默认设置。
如果你在上述情况下使用Types.DocumentArray，你就可以push()一个没有_id的子文档。
例如：
const user = new User({ blogPosts: [] });

user.blogPosts.push({ title: 'test' });

// Would not work if you did `blogPosts: BlogPost[]`



7、Model类的泛型参数说明
Model<
// 通常指“文档接口”类型
TRawDocType,

// 通常指定义“查询助手”的接口类型
TQueryHelpers = {},
// 通常指定义“实例方法”的接口类型
TInstanceMethods = {},
// 通常指定义“虚方法”的接口类型
TVirtuals = {},

// 通常指通过“Model”new出来的“实例对象”的类型
THydratedDocumentType = HydratedDocument<TRawDocType, TVirtuals & TInstanceMethods, TQueryHelpers>,

TSchema = any
>
----------------------------
Model<
// 通常指“文档接口”
InferSchemaType<TSchema>,

// 通常指定义“查询助手”的接口类型
ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>,
// 通常指定义“实例方法”的接口类型
ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
// 通常指定义“虚方法”的接口类型
{},

// 通常指通过“Model对象”new出来的“实例对象”的类型
HydratedDocument<
InferSchemaType<TSchema>,
ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>
>,

TSchema
>



8、model、client.model的泛型参数说明以及其创建出来的值的类型
model<
// 通常指“文档接口”类型
IKitty,

// Model类型
IKittyModel,

// 通常指定义“查询助手”的接口类型
IKittyQueryHelpers
>

其创建出来的值的类型通常是个“联合类型”，例如：
Model<IKitty, IKittyQueryHelpers, IKittyMethods> & IKittyModel;
前者就是上面提到的“Model类”类型，后者通常是表示一个继承了“Model类”类型的又定义了“静态方法”的接口类型的“Model类”类型。



9、QueryWithHelpers泛型参数说明
type QueryWithHelpers<
// 通常是指通过“Model对象.find()”返回的结果类型，通常是数组类型，其成员类型通常也是指“Model对象”new出来的“实例对象”的类型
ResultType,

// 通常也是指“Model对象”new出来的“实例对象”的类型
DocType,

// 通常指定义“查询助手”的接口类型
THelpers = {},

RawDocType = DocType
>
=
Query<ResultType, DocType, THelpers, RawDocType> & THelpers;



10、“Model对象”new出来的“实例对象”的类型
HydratedDocument<
// 通常指“文档接口”类型
IKitty,

// 通常指定义“实例方法”的接口类型
IKittyMethods,

// 通常指定义“查询助手”的接口类型
IKittyQueryHelpers
>



这里给出一个实际解释上面记录的几个点的代码例子：
    import {
      type ConnectOptions,
      type Connection,
      type HydratedDocument,
      type QueryWithHelpers,

      Mongoose,
      Schema,
      Model,
      Types,

      // @ts-ignore
    } from 'npm:mongoose';



    type TQueryWithHelpers = QueryWithHelpers<Array<TKittenInstance>, TKittenInstance, IKittyQueryHelpers>;
    type TKittenModel = Model<IKitty, IKittyQueryHelpers, IKittyMethods> & IKittyModel;
    type TKittenInstance = HydratedDocument<IKitty, IKittyMethods, IKittyQueryHelpers>;

    // Subdocument definition.
    interface IInfo {
      text: string;
    }

    interface IInfoMethods {
      getText(): string;
    }

    interface IKitty {
      name: string;

      color: string;

      sex: string;

      time: number;

      eye: string;

      foot: string;

      info: Types.Subdocument<Types.ObjectId> & IInfo & HydratedDocument<IInfo, IInfoMethods>;
    }

    interface IKittyModel
      extends Model<IKitty, IKittyQueryHelpers, IKittyMethods> {
      GetTime( kitten: TKittenInstance ): number;

      GetEye( kitten: TKittenInstance ): string;

      GetFoot( kitten: TKittenInstance ): string;
    }

    interface IKittyMethods {
      speak(): void;

      getColor(): string;

      getSex(): string;

      getInfo(): string;
    }

    interface IKittyQueryHelpers {
      FindByName( name: string ): TQueryWithHelpers;

      FindBySex( sex: string ): TQueryWithHelpers;
    }

    // 创建一个“Schema”，相当于定义了面向对象编程中的一个“接口”。
    const KittySchema: Schema<
      IKitty,
      IKittyModel,
      IKittyMethods,
      IKittyQueryHelpers
    > = new Schema<
      IKitty,
      IKittyModel,
      IKittyMethods,
      IKittyQueryHelpers
    >(
      // 为这个“Schema”（相当于面向对象编程中的“接口”）添加“属性”。
      {
        name: {
          type: String,
          default: '喵喵',
          required: true,
        },
        color: {
          type: String,
          default: '灰蓝',
        },
        sex: {
          type: String,
          default: '铁蛋',
        },
        time: {
          type: Number,
          default: Date.now(),
        },
        eye: {
          type: String,
          default: '蓝眼睛',
        },
        foot: {
          type: String,
          default: '白手套',
        },
        info: new Schema<
          IInfo,
          Model<IInfo, {}, IInfoMethods>,
          IInfoMethods
        >(
          {
            text: {
              type: String,
              default: '关于这只喵喵的一些信息。',
              required: true,
            },
          },
          {
            methods: {
              getText( this: HydratedDocument<IInfo, IInfoMethods> ): string{
                return `{ _id: ${ this._id }, text: ${ this.text } }`;
              },
            },
          }
        ),
      },
      // 为这个“Schema”（相当于面向对象编程中的“接口”）添加“方法”，如：“实例方法”、“静态方法”、“查询帮助方法”。
      {
        // 为这个“Schema”（相当于面向对象编程中的“接口”）添加“实例方法”。
        methods: {
          speak( this: TKittenInstance ): void{
            const greeting: string = this.name
                                     ? `Meow name is ${ this.name }.`
                                     : 'I don\'t have a name.';

            console.log( `\n${ greeting }\n` );
          },
          getColor( this: TKittenInstance ): string{
            console.log( `\nMy color is ${ this.color }.\n` );

            return this.color;
          },
          getSex( this: TKittenInstance ): string{
            console.log( `\nMy sex is ${ this.sex }.\n` );

            return this.sex;
          },
          getInfo( this: TKittenInstance ): string{
            console.log( `\nMy info is ${ this.info.getText() }.\n` );
            // 返回此子文档的顶级文档：this.info.ownerDocument()。
            // console.log( `this.info.ownerDocument(): ${ this.info.ownerDocument() }.\n` );
            // 返回此子文档父文档：this.info.parent()。
            // console.log( `this.info.parent(): ${ this.info.parent() }.\n` );
            // 返回此子文档父文档：this.info.$parent()。
            // console.log( `this.info.$parent(): ${ this.info.$parent() }.\n` );

            return this.info.getText();
          },
        },
        // 为这个“Schema”（相当于面向对象编程中的“接口”）添加“静态方法”。
        statics: {
          GetTime( kitten: TKittenInstance ): number{
            console.log( `\nMy time is ${ kitten.time }.\n` );

            return kitten.time;
          },
          GetEye( kitten: TKittenInstance ): string{
            console.log( `\nMy eye is ${ kitten.eye }.\n` );

            return kitten.eye;
          },
          GetFoot( kitten: TKittenInstance ): string{
            console.log( `\nMy foot is ${ kitten.foot }.\n` );

            return kitten.foot;
          },
        },
        // 为这个“Schema”（相当于面向对象编程中的“接口”）添加“查询帮助方法”，也是一种“静态方法”。
        query: {
          FindByName(
            this: TQueryWithHelpers,
            name: string
          ): TQueryWithHelpers{
            return this.find( {
              name,
            } );
          },
          FindBySex(
            this: TQueryWithHelpers,
            sex: string
          ): TQueryWithHelpers{
            return this.find( {
              sex,
            } );
          },
        },
      },
    );

    // 为这个“Schema”（相当于面向对象编程中的“接口”）添加“实例方法”。
    /*
     KittySchema.methods.speak = function ( this: TKittenInstance ): void{
     const greeting: string = this.name
     ? `Meow name is ${ this.name }.`
     : 'I don\'t have a name.';

     console.log( `\n${ greeting }\n` );
     };
     */
    // 为这个“Schema”（相当于面向对象编程中的“接口”）添加“静态方法”。
    /*
     KittySchema.statics.GetEye = function ( kitten: TKittenInstance ): string{
     console.log( `\nMy eye is ${ kitten.eye }.\n` );

     return kitten.eye;
     };
     */
    // 为这个“Schema”（相当于面向对象编程中的“接口”）添加“查询帮助方法”，也是一种“静态方法”。
    /*
     KittySchema.query.FindByName = function (
     this: TQueryWithHelpers,
     name: string ): TQueryWithHelpers{
     return this.find( {
     name,
     } );
     };
     */

    // 为这个“Schema”（相当于面向对象编程中的“接口”）添加“实例方法”。
    /*
     KittySchema.method( {
     getSex( this: TKittenInstance ): string{
     console.log( `\nMy sex is ${ this.sex }.\n` );

     return this.sex;
     },
     } );
     */
    // 为这个“Schema”（相当于面向对象编程中的“接口”）添加“静态方法”。
    /*
     KittySchema.static( {
     GetFoot( kitten: TKittenInstance ): string{
     console.log( `\nMy foot is ${ kitten.foot }.\n` );

     return kitten.foot;
     },
     } );
     */

    // 根据上面创建的“Schema”（相当于面向对象编程中的“接口”），生成一个对应的“Model”，其相当于面向对象编程中的“类”，并且这个类是实现了上面创建的“接口”。
    const Kitten: TKittenModel = client.model<
      IKitty,
      IKittyModel,
      IKittyQueryHelpers
    >(
      // modelName
      'Kitten',
      // schema
      KittySchema,
      // 这个参数表示要在数据库里表示的“集合名”，不存在就会创建这个集合。
      'kittens'
    );

    // 查找。
    let kittenQuantity: number = ( await Kitten.find() ).length;

    // 根据上面生成的“Model”（相当于面向对象编程中的“类”），实例化一个个实体对象。
    const kitten001: TKittenInstance = new Kitten( {
      name: `喵喵${ ++kittenQuantity }号`,
      sex: '翠花',
      info: {
        text: `关于这只喵喵${ kittenQuantity }号的一些信息。`,
      },
    } );
    const kitten002: TKittenInstance = new Kitten( {
      name: `喵喵${ ++kittenQuantity }号`,
      info: {
        text: `关于这只喵喵${ kittenQuantity }号的一些信息。`,
      },
    } );

    // 保存到数据库中。
    await kitten001.save();
    await kitten002.save();

    // 查找。
    const kittens: Array<TKittenInstance> = await Kitten.find()
    .FindBySex( '翠花' );
    kittens.forEach( ( kitten: TKittenInstance, ): void => {
      kitten.speak();
      kitten.getColor();
      kitten.getSex();
      kitten.getInfo();
      Kitten.GetTime( kitten );
      Kitten.GetEye( kitten );
      Kitten.GetFoot( kitten );
    } );
